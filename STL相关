STL:标准模板库（容器、算法、迭代器）
顺序容器+关联式容器
一、顺序容器：
1.vector
  内存空间可增长的动态数组，连续的线性空间，底层实现是数组；
  扩容原理：
  vector就是一个动态增长的数组，里面有一个指针指向一片连续的空间，当空间装不下的时候，会申请一片更大的空间，将原来的数据拷贝过去，并释放原来的旧空间。
  增删时间复杂度为O(n);
  支持+，+=，<等操作符。
  维护三个迭代器：start, finish, end_of_storage
  
2.deque双端队列
  双向开口的存储空间分段连续的数据结构，每段数据空间内部是连续的，底层实现是一个中控器和多个数据缓冲区
  deque与vector区别：
  1）对首尾进行插入和删除O(1)
  2）deque没有容量概念，随时可以增加一段新的空间并连接
  有四部分数据空间，在程序运行时在堆上动态分布
  中控器(map)维护一组指针，指向每一段数据空间(缓冲区)的起始地址。
  迭代器(cur,first,last,node)-(实际访问位置，访问元素区间，访问元素入口地址)
  map扩容原理：
  先填满缓冲区，填满后配置更大的，拷贝原来的，释放原空间。
  
3.list
  内存空间不连续，底层实现是deque双向链表，只能通过指针访问数据
  数据的随机存取O(n)，但是增删高效
  不支持+，+=，<等操作符。
 
 4.stack
  list和deque实现，不用vector是因为扩容耗时
  
5.queue
  list和deque实现
  
6.priority_queue
  底层实现时vector，heap为处理规则管理底层容器实现
  
7.set/multiset
  底层实现是红黑树，有序(默认升序)不可重复，multi可重复；
  插入和删除仅仅需要指针操作节点即可，不涉及内存移动和拷贝；
  也是以键值对的方式存在，只是键值与实值相同；
  multiset插入删除的时间复杂度为O(logn)
  
8.map/multimap
  底层实现是红黑树，有序不可重复，multi可重复；
  红黑树的每一个节点都代表map的一个元素，对于map进行的查找，删除，添加的操作都是相当于对于红黑树的操作，故红黑树的效率决定map的效率
  基于key的快速检索能力，查询、插入、删除时间复杂度都是O(logn)；
  元素插入按照顺序插入，不能指定位置插入可以改变value，但不能修改key
  通过first,second访问pair的元素
  
  
9.unordered_set/unordered_multiset
  底层实现是哈希表，无序不可重复，multi可重复；
  
10.unordered_map/unordered_multimap
  底层实现是哈希表，无序不可重复，multi可重复；
  内部实现了一个hash表，因此排序是杂乱无序的，查找速度特别快
  
11.map/unordered_map的区别
  1）map空间占用率较高，虽然提高了运行效率，但是因为每一个节点都需要额外保存父节点，孩子节点以及红/黑性质，使得每一个节点都占用大量的空间；
  2）hash表的建立比较耗费时间
  
12.STL 中迭代器的作用，有指针为何还要迭代器
  1） Iterator（迭代器）模式又称Cursor（游标）模式，用于提供一种方法顺序访问一个聚合对象中各个元素, 而又不需暴露该对象的内部表示。
  2） 迭代器不是指针，是类模板，表现的像指针。他只是模拟了指针的一些功能，通过重载了指针的一些操作符，->、*、++、--等，相当于一种智能指针。
  3） 迭代器产生原因：
      Iterator类的访问方式就是把不同集合类的访问逻辑抽象出来，使得不用暴露集合内部的结构而达到循环遍历集合的效果。
   
13.STL 迭代器是怎么删除元素
  1） 对于序列容器vector,deque来说，使用erase(itertor)后，后边的每个元素的迭代器都会失效，但是后边每个元素都会往前移动一个位置，但是erase会返回下一个有效的迭代器；
  2） 对于关联容器map set来说，使用了erase(iterator)后，当前元素的迭代器失效，但是其结构是红黑树，删除当前元素的，不会影响到下一个元素的迭代器，
      所以在调用erase之前，记录下一个元素的迭代器即可。
  3） 对于list来说，它使用了不连续分配的内存，并且它的erase方法也会返回下一个有效的iterator
  
 14.平衡二叉树（AVL树）和红黑树
  1）平衡二叉树又称为AVL树，是一种特殊的二叉排序树。其左右子树都是平衡二叉树，且左右子树高度之差的绝对值不超过1。
  2）红黑树是一种二叉查找树，但在每个节点增加一个存储位表示节点的颜色，可以是红或黑（非红即黑），
     红黑树是一种弱平衡二叉树，相对于要求严格的AVL树来说，它的旋转次数少，所以对于搜索，插入，删除操作较多的情况下，通常使用红黑树。
  3）所以红黑树在查找，插入删除的性能都是O(logn)，且性能稳定，所以STL里面很多结构包括map底层实现都是使用的红黑树。
  
15.hash表
  哈希表的实现主要包括构造哈希和处理哈希冲突：构造哈希，主要包括直接地址法，除留余数法。
  处理哈希冲突：当哈希表关键字集合很大时，关键字值不同的元素可能会映射到哈希表的同一地址上，这样的现象称为哈希冲突。常用的解决方法有：
  1） 开放定址法，冲突时，用某种方法继续探测哈希表中的其他存储单元，直到找到空位置为止。（如，线性探测，平方探测）
  2） 再哈希法：当发生冲突时，用另一个哈希函数计算地址值，直到冲突不再发生。
  3） 链地址法：将所有哈希值相同的key通过链表存储，key按顺序插入链表中。
