1.new/delete和malloc/free的区别:
  new/delete是C++的运算符，会调用对象的构造和析构函数，可动态申请内存和释放内存，处理数组时需要加[]；
  malloc/free是C++/C的标准库函数，在创建时需要指定内存大小。

2.new构造过程：
  new分配对象内存：
  1）使用operator new函数分配足够大的内存空间
  2）编译器运行构造函数以构造对象，并为其传入初值
  3）对象构造完成后，返回一个指向该对象的指针
  delete析构过程：
  1）调用析构函数释放new的内存
  2）释放整个对象的内存
  
3.引用做函数参数的特点
  1）被调函数的形参成为原来主函数中调用的实参的别名，因此改变形参即改变实参；
  2）在内存中没有产生实参的副本，所以传递参数的效率和空间都较好；
  3）可以在函数内部对此参数进行修改

4.常引用(const int &a)
  主要用来修饰形参，提高程序效率且保护传递给函数的数据不在函数中被改变
  
5.引用和指针的区别
  1）引用必须初始化，指针不需要；
  2）引用初始化后不能改变，指针可以改变指向的对象；
  3）不存在指向空值的引用，存在指向空值的指针；
  4）指针是一个新的变量，指向一块内存，引用只是一个别名，还是变量本身。
  5）引用只有一级，指针可以有多级。
  
6.引用必须遵守的规则
  1）不能返回局部变量的引用（局部变量在函数返回后被销毁，被返回的引用指向为空）；
  2）不能返回函数内部new分配的内存的引用（被函数返回的引用只是作为临时变量，而没有被赋予实际变量，引用所指的空间无法被释放）；
  3）可以返回类成员的引用，但最好是const；
  4）流操作符重载返回值声明为引用

7.引用实现动态绑定
  引用既可以指向基类对象也可以指向子类对象，这是动态绑定的关键，引用调用的虚函数数在运行时确定，被调用的函数是引用所指的对象的实际类型定义的。
  
 8.C++三大特性
  封装：隐藏实现细节，使得代码模块化；
  继承：子类继承父类数据和方法，扩展已存在模块，实现代码重用；
  多态：一个接口，多种实现，子类重写父类虚函数，实现接口重用。
  
9.多态的实现原理
  在继承体制下，将父类的某个函数加上virtual关键字，写成虚函数，在子类中对这个虚函数进行重写，利用父类指针或引用调用虚函数。
  虚函数的调用，每个对象内部都有一个虚指针，在构造子类对象时，执行构造函数中进行虚表的创建和虚指针的初始化，该虚指针被初始化为本类的虚表。
  所以在程序中，不管你的对象类型如何转换，但该对象内部的虚表指针是固定的，所以呢，才能实现动态的对象函数调用，这就是C++多态性实现的原理。

10.虚函数原理
  1）编译器在发现父类中有虚函数时，会自动为每个含有虚函数的类生成一份虚函数表，也叫做虚表，该表是一个一维数组，虚表里保存了虚函数的入口地址。
  2）编译器会在每个对象的前四个字节中保存一个虚表指针，即（vptr),指向对象所属类的虚表。
    在程序运行时的合适时机，根据对象的类型去初始化vptr，从而让vptr指向正确的虚表，从而在调用虚函数时，能找到正确的函数。
  3）在派生类定义对象时，程序运行会自动调用构造函数，在构造函数中创建虚表并对虚表初始化。
    在构造子类对象时，会先调用父类的构造函数，此时，编译器只“看到了”父类，并为父类对象初始化虚表指针，令它指向父类的虚表；
    当调用子类的构造函数时，为子类对象初始化虚表指针，令它指向子类的虚表
    
11.const
  1)#define与const的区别
    a)宏定义的常量没有类型，只是简单的字符串替换，const定义的常量有类型，存放在静态存储区
    b)宏定义的变量在预处理时进行替换，可能有多个拷贝，const定义的变量在编译时确定其值，只有一个拷贝
    c)宏定义的常量不可以用指针区指向，const可以
    d)宏定义可以定义简单的函数，const不行    
  2）const修饰类的成员变量，常量不能被修改；修饰类的成员函数，函数不会修改类中的数据成员，不会调用非const成员函数；而非const函数可以调用const函数
  3）const char *p指向字符常量的指针，即常量指针，指向可以改变，指向的值不能改变
     char const *p等同于const char *p
     char* const p指向字符的指针常量，即指针常量，指向不能改变，指向的值可以改变

12.C++的内存管理
  1）静态存储区：内存在编译时已经分配好，存放全局变量、静态变量及常量；
  2）栈区：执行函数时，函数内局部变量内存在栈上创建，执行结束后编译器自动释放；
  3）堆区：动态内存分配，用new/malloc申请内存，程序员负责创建和释放。
  
13.内存泄漏
  动态分配的堆内存未释放或无法释放，造成系统内存浪费
  1）类的构造和析构函数中的new和delete没有配套；
  2）释放数组delete[]；
  3）没有将基类的析构函数定义为虚函数：当基类指针指向子类对象时，若析构函数不是virtual，子类的析构函数不会被调用，子类的资源没有释放
  4）没有清除嵌套的对象指针
  
14.栈溢出
  函数中的局部变量造成的溢出，栈大小1-2M
  1）函数调用层次过深，调用一次，局部变量、参数压栈一次；
  2）局部变量内存过大；
  解决方法：
  1）增大分配内存大小
  2)使用堆内存：定义指针，动态申请/static

15.野指针
  未初始化或未清零的指针，指向的内存不确定
  1）指针未初始化；
  2）指针指向的内存被释放，但指针没有被置空；
  3）指针超过变量的作用范围，即指针越界。
  
  悬挂指针与野指针
  悬挂指针：当指针所指向的对象被释放，但是该指针没有任何改变，以至于其仍然指向已经被回收的内存地址，这种情况下该指针被称为悬挂指针；
  
16.函数调用过程
  1）栈内存分配存储空间；
  2）实参的存储空间复制值到形参栈空间
  3）运算
  形参在函数调用前没有内存空间，调用结束后，形参弹出栈空间，清除内存；
  数组作为参数的函数调用是地址传递，形参和实参指向相同空间，调用结束后，形参指针被销毁，但指向的空间依然存在；
  多个返回值，返回地址/指针。
  
17.堆栈区别
  1）栈存放函数参数，局部变量，编译器自动释放；
  2）堆由new/malloc开辟，程序员delete/free手动释放，若未释放，操作系统自动回收；
  3）堆的内存空间不连续，有大量碎片；
  4）堆的生长空间自下而上，地址越大；栈生长空间自上而下，地址越小。

18.struct/class/union
  struct和class权限：struct默认公有，class默认私有
  struct和union：
  1）struct时不同类型数据组合成一个整体，是自定义类型，union不同类型变量共同占有一段内存；
  2）struct各成员有独立地址，同时存在；union同一时刻只有一个成员有内存；
  3）sizeof(struct)是内存对齐后所有成员长度的和，sizeof(union)是最长数据成员的长度。

19.struct为什么要内存对齐
  1）平台移植：硬件平台不能访问任意地址上的任意数据；
  2）硬件原因：内存对齐后，CPU访问速度大大提升。

20.深拷贝和浅拷贝
  深拷贝：在堆区重新申请空间，进行拷贝；浅拷贝：简单的复制拷贝
  类的对象发生复制过程时，资源重新分配了就是深拷贝，没有重新分配就是浅拷贝；
  浅拷贝会导致重复释放堆区内存。
  
21.拷贝构造函数的调用时机
  1）使用一个一创建的对象初始化新对象；
  2）值传递的方式给函数参数传值；
  3）以值方式返回局部对象
  
22. 静态绑定和动态绑定
	1）函数依赖对象的类型，静态绑定在编译期间确定，动态绑定在运行期间确定
	  只有虚函数是动态绑定。
	2）静态多态：函数重载和运算符重载；动态多态：子类和虚函数运行时多态

23. 构造函数不定义为虚函数，析构函数一般为虚函数
  1）因为创建一个对象时需要确定对象的类型，而虚函数是在运行时确定其类型的。而在构造一个对象时，由于对象还未创建成功，编译器无法知道对象的实际类型，是类本身还是类的派生类等等
  2）虚函数的调用需要虚函数表指针，而该指针存放在对象的内存空间中；若构造函数声明为虚函数，那么由于对象还未创建，还没有内存空间，更没有虚函数表地址用来调用虚函数即构造函数了
  1）首先析构函数可以为虚函数，当析构一个指向派生类的基类指针时，最好将基类的析构函数声明为虚函数，否则可以存在内存泄露(若子类中有属性开辟到堆区)的问题。
  2）如果析构函数不被声明成虚函数，则编译器实施静态绑定，在删除指向派生类的基类指针时，只会调用基类的析构函数而不调用派生类析构函数，这样就会造成派生类对象析构不完全。

24. 子类析构时，要调用父类的析构函数吗
  不用显式调用，会自动调用，析构函数调用的次序时先派生类后基类的。和构造函数的执行顺序相反。
  并且析构函数要是virtual的，否则如果用父类的指针指向子类对象的时候，析构函数静态绑定，不会调用子类的析构。

25. static
  1）函数体内： static 修饰的局部变量作用范围为该函数体，不同于auto变量，其内存只被分配一次，因此其值在下次调用的时候维持了上次的值
  2）模块内：static修饰全局变量或全局函数，可以被模块内的所有函数访问，但是不能被模块外的其他函数访问，使用范围限制在声明它的模块内
  3）类中：修饰成员变量，表示该变量属于整个类所有，所有对象共享一份数据，类内声明，类外初始化。
  4）类中：修饰成员函数，表示该函数属于整个类所有，不接受this指针，只能访问类中的static成员变量
  注意和const的区别！！！const强调值不能被修改，而static强调唯一的拷贝，对所有类的对象。

26. 成员变量和成员函数存储
    分开存储，只有非静态成员变量才属于类的对象
    空对象占1个字节，为了区分位置和地址

27. this指针
    this指针指向被调用的成员函数所属的对象，隐含每一个非静态成员函数内的一种指针，本质是指针常量，指向不可修改。
    1）形参和实参同名，可用this区分；
    2）非静态成员函数返回对象本身，可用this。

28.extern "C"
能够调用其它语言的代码，并进行编译
	  
29.inline
  提高函数效率，复制代码，省去函数调用的开销
  虚函数可以是inline，但是表现为多态性时不行，inline在编译期间内联，而虚函数的多态性在运行期，只能在有实际对象时才会有inline virtual
  
30.volatile
  避免编译器优化（可能从寄存器中读取），直接从内存中读取变量
  const和指针都可以是volatile
	  
31.位域（Bit Field）
  将数据以位的形式紧凑地存储，能够节省数据单元存储空间，但是不能移植到不同平台
  类型必须是整型或枚举类型

32.c++的四种类型转换
  1)tatic_cast：风险很低
    a)自动类型转换，如short转int,int转double；
    b)void 指针和具体类型指针之间的转换，如void*转int*；
    c)有转换构造函数或者类型转换函数的类与其它类型之间的转换，如 double 转 Complex（调用转换构造函数）、Complex 转 double（调用类型转换函数）  
  2)const_cast :去掉表达式的 const 修饰或 volatile 修饰
  3)reinterpret_cast:是对二进制位的重新解释，不会借助已有的转换规则对数据进行调整，非常简单粗暴，所以风险很高
  4)dynamic_cast:在类的继承层次之间进行类型转换

33.C和C++有什么区别？
  C++是面向对象的语言，而C是面向过程的语言；
  C++引入new/delete运算符，取代了C中的malloc/free库函数；
  C++引入引用的概念，而C中没有；
  C++引入类的概念，而C中没有；
  C++引入函数重载的特性，而C中没有
  
34.怎么理解面向对象
  1）和人类的思维习惯一致；
  2）对象模拟实体，稳定性好；
  3）可重用性好，可维护；

35.系统调用与标准库函数区别
  系统调用发生在内核空间，因此如果在用户空间的一般应用程序中使用系统调用来进行文件操作，会有用户空间到内核空间切换的开销，因此开销较大
  使用库函数来对文件进行操作，不管是读写操作，都是对硬件的操作，都必然会引起系统调用
  读写文件通常是大量的数据，因为缓冲区技术，在用户空间和内核空间对文件操作都使用了缓冲区，使用库函数可以大大减少系统调用的次数。
  
36.结构体多个指针指向同一段内存
  多个指针指向同一段内存时，某个指针释放这段内存可能会导致其他指针的非法操作。因此在释放前一定要确保其他指针不再使用这段内存空间
  
37.sizeof 和strlen 的区别
  sizeof是一个操作符，strlen是库函数。 
  sizeof的参数可以是数据的类型，也可以是变量，而strlen只能以结尾为‘\0’的字符串作参数。
  编译器在编译时就计算出了sizeof的结果，而strlen函数必须在运行时才能计算出来。
  sizeof计算的是数据类型占内存的大小，而strlen计算的是字符串实际的长度。 
  
38.strcpy、sprintf 与memcpy 的区别
  操作对象不同，strcpy 的两个操作对象均为字符串，sprintf 的操作源对象可以是多种数据类型， 目的操作对象是字符串，memcpy 的两个对象就是两个任意可操作的内存地址，并不限于何种数据类型。 
  执行效率不同，memcpy 最高，strcpy 次之，sprintf 的效率最低。 
  实现功能不同，strcpy 主要实现字符串变量间的拷贝，sprintf 主要实现其他数据类型格式到字 符串的转化，memcpy 主要是内存块间的拷贝

39.什么是智能指针？智能指针有什么作用？分为哪几种？各自有什么样的特点
  智能指针是一个RAII类模型，用于动态分配内存，其设计思想是将基本类型指针封装为（模板）类对象指针，并在离开作用域时调用析构函数，使用delete删除指针所指向的内存空间；
  智能指针的作用是，能够处理内存泄漏问题和空悬指针问题；
  分为auto_ptr、unique_ptr、shared_ptr和weak_ptr四种：
  1）auto_ptr，实现独占式拥有的概念，同一时间只能有一个智能指针可以指向该对象；但auto_ptr在C++11中被摒弃：
    a)对象所有权的转移，比如在函数传参过程中，对象所有权不会返还，从而存在潜在的内存崩溃问题；
    b)不能指向数组，也不能作为STL容器的成员
  2)unique_ptr，实现独占式拥有的概念，同一时间只能有一个智能指针可以指向该对象，因为无法进行拷贝构造和拷贝赋值，但是可以进行移动构造和移动赋值
  3)shared_ptr，实现共享式拥有的概念，即多个智能指针可以指向相同的对象，该对象及相关资源会在其所指对象不再使用之后，自动释放与对象相关的资源
  4)weak_ptr，解决shared_ptr相互引用时，两个指针的引用计数永远不会下降为0，从而导致死锁问题。而weak_ptr是对对象的一种弱引用，可以绑定到shared_ptr，但不会增加对象的引用计数
  
40.shared_ptr是如何实现的？
  构造函数中计数初始化为1；
  拷贝构造函数中计数值加1；
  赋值运算符中，左边的对象引用计数减1，右边的对象引用计数加1；
  析构函数中引用计数减1；
  在赋值运算符和析构函数中，如果减1后为0，则调用delete释放对象
  
41.右值引用有什么作用？
  右值引用的主要目的是为了实现转移语义和完美转发，消除两个对象交互时不必要的对象拷贝，也能够更加简洁明确地定义泛型函数
  
42.void (*0)( ) ：是一个返回值为void，参数为空的函数指针0。 
  (void (*)( ))0：把0转变成一个返回值为void，参数为空的函数指针。 
  (void ()( ))0：在上句的基础上加*表示整个是一个返回值为void，无参数，并且起始地址为0的函数的名字。 
  ((void ()( ))0)( )：这就是上句的函数名所对应的函数的调用
  
43.设置地址为0x67a9 的整型变量的值为0xaa66（强制类型转换）长度一致
  int *ptr; 
  ptr = (int *)0x67a9; 
  *ptr = 0xaa66; 
  
44.句柄和指针的区别和联系是什么
  Windows系统用句柄标记系统资源，隐藏系统的信息。你只要知道有这个东西，然后去调用就行了，它是个32it的uint。
  指针则标记某个物理内存地址，两者是不同的概念。
  
45.顶层const和底层const 
  底层const是代表对象本身是一个常量（不可改变）；
  顶层const是代表指针的值是一个常量,而指针的值(即对象的地址)的内容可以改变（指向的不可改变）

46.拷贝初始化和直接初始化，初始化和赋值的区别：
  要点就是拷贝初始化和直接初始化调用的构造函数是不一样的，但是当类进行复制时，类会自动生成一个临时的对象，然后再进行拷贝初始化
  ClassTest ct1(“ab”); 这条语句属于直接初始化，它不需要调用复制构造函数，直接调用构造函数ClassTest(constchar *pc)，所以当复制构造函数变为私有时，它还是能直接执行的。 
  ClassTest ct2 = “ab”; 这条语句为复制初始化，它首先调用构造函数 ClassTest(const char* pc) 函数创建一个临时对象，然后调用复制构造函数，
    把这个临时对象作为参数，构造对象ct2；所以当复制构造函数变为私有时，该语句不能编译通过。 
  ClassTest ct3 = ct1;这条语句为复制初始化，因为 ct1 本来已经存在，所以不需要调用相关的构造函数，而直接调用复制构造函数，把它值复制给对象 ct3；
    所以当复制构造函数变为私有时，该语句不能编译通过。 
  ClassTest ct4（ct1）;这条语句为直接初始化，因为 ct1 本来已经存在，直接调用复制构造函数，生成对象 ct3 的副本对象 ct4。所以当复制构造函数变为私有时，该语句不能编译通过
  
47.C++异常机制：
  异常事件发生时，程序使用throw关键字抛出异常表达式，抛出点称为异常出现点，由操作系统为程序设置当前异常对象，然后执行程序的当前异常处理代码块，
  在包含了异常出现点的最内层的try块，依次匹配catch语句中的异常对象（只进行类型匹配，catch参数有时在catch语句中并不会使用到）。 
  若匹配成功，则执行catch块内的异常处理语句，然后接着执行try…catch…块之后的代码。
  如果在当前的try…catch…块内找不到匹配该异常对象的catch语句,则由更外层的try…catch…块来处理该异常；
  如果当前函数内所有的try…catch…块都不能匹配该异常，则递归回退到调用栈的上一层去处理该异常。 
  如果一直退到主函数main()都不能处理该异常，则调用系统函数terminate()终止程序

