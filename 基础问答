1.new/delete和malloc/free的区别:
  new/delete是C++的运算符，会调用对象的构造和析构函数，可动态申请内存和释放内存，处理数组时需要加[]；
  malloc/free是C++/C的标准库函数，在创建时需要指定内存大小。

2.new构造过程：
  new分配对象内存：
  1）使用operator new函数分配足够大的内存空间
  2）编译器运行构造函数以构造对象，并为其传入初值
  3）对象构造完成后，返回一个指向该对象的指针
  delete析构过程：
  1）调用析构函数释放new的内存
  2）释放整个对象的内存
  
3.引用做函数参数的特点
  1）被调函数的形参成为原来主函数中调用的实参的别名，因此改变形参即改变实参；
  2）在内存中没有产生实参的副本，所以传递参数的效率和空间都较好；
  3）可以在函数内部对此参数进行修改

4.常引用(const int &a)
  提高程序效率且保护传递给函数的数据不在函数中被改变
  
5.引用和指针的区别
  1）引用必须初始化，指针不需要；
  2）引用初始化后不能改变，指针可以改变指向的对象；
  3）不存在指向空值的引用，存在指向空值的指针；
  4）指针是一个新的变量，指向一块内存，引用只是一个别名，还是变量本身。
  5）引用只有一级，指针可以有多级。
  
6.引用必须遵守的规则
  1）不能返回局部变量的引用（局部变量在函数返回后被销毁，被返回的引用指向为空）；
  2）不能返回函数内部new分配的内存的引用（被函数返回的引用只是作为临时变量，而没有被赋予实际变量，引用所指的空间无法被释放）；
  3）可以返回类成员的引用，但最好是const；
  4）流操作符重载返回值声明为引用

7.引用实现动态绑定
  引用既可以指向基类对象也可以指向子类对象，这是动态绑定的关键，引用调用的虚函数数在运行时确定，被调用的函数是引用所指的对象的实际类型定义的。
  
 8.C++三大特性
  封装：隐藏实现细节，使得代码模块化；
  继承：子类继承父类数据和方法，扩展已存在模块，实现代码重用；
  多态：一个接口，多种实现，子类重写父类虚函数，实现接口重用。
  
9.多态的实现原理
  在继承体制下，将父类的某个函数加上virtual关键字，写成虚函数，在子类中对这个虚函数进行重写，利用父类指针或引用调用虚函数。
  虚函数的调用，每个对象内部都有一个虚指针，在构造子类对象时，执行构造函数中进行虚表的创建和虚指针的初始化，该虚指针被初始化为本类的虚表。
  所以在程序中，不管你的对象类型如何转换，但该对象内部的虚表指针是固定的，所以呢，才能实现动态的对象函数调用，这就是C++多态性实现的原理。
