1.new/delete和malloc/free的区别:
  new/delete是C++的运算符，会调用对象的构造和析构函数，可动态申请内存和释放内存，处理数组时需要加[]；
  malloc/free是C++/C的标准库函数，在创建时需要指定内存大小。

2.new构造过程：
  new分配对象内存：
  1）使用operator new函数分配足够大的内存空间
  2）编译器运行构造函数以构造对象，并为其传入初值
  3）对象构造完成后，返回一个指向该对象的指针
  delete析构过程：
  1）调用析构函数释放new的内存
  2）释放整个对象的内存
  
3.引用做函数参数的特点
  1）被调函数的形参成为原来主函数中调用的实参的别名，因此改变形参即改变实参；
  2）在内存中没有产生实参的副本，所以传递参数的效率和空间都较好；
  3）可以在函数内部对此参数进行修改

4.常引用(const int &a)
  主要用来修饰形参，提高程序效率且保护传递给函数的数据不在函数中被改变
  
5.引用和指针的区别
  1）引用必须初始化，指针不需要；
  2）引用初始化后不能改变，指针可以改变指向的对象；
  3）不存在指向空值的引用，存在指向空值的指针；
  4）指针是一个新的变量，指向一块内存，引用只是一个别名，还是变量本身。
  5）引用只有一级，指针可以有多级。
  
6.引用必须遵守的规则
  1）不能返回局部变量的引用（局部变量在函数返回后被销毁，被返回的引用指向为空）；
  2）不能返回函数内部new分配的内存的引用（被函数返回的引用只是作为临时变量，而没有被赋予实际变量，引用所指的空间无法被释放）；
  3）可以返回类成员的引用，但最好是const；
  4）流操作符重载返回值声明为引用

7.引用实现动态绑定
  引用既可以指向基类对象也可以指向子类对象，这是动态绑定的关键，引用调用的虚函数数在运行时确定，被调用的函数是引用所指的对象的实际类型定义的。
  
 8.C++三大特性
  封装：隐藏实现细节，使得代码模块化；
  继承：子类继承父类数据和方法，扩展已存在模块，实现代码重用；
  多态：一个接口，多种实现，子类重写父类虚函数，实现接口重用。
  
9.多态的实现原理
  在继承体制下，将父类的某个函数加上virtual关键字，写成虚函数，在子类中对这个虚函数进行重写，利用父类指针或引用调用虚函数。
  虚函数的调用，每个对象内部都有一个虚指针，在构造子类对象时，执行构造函数中进行虚表的创建和虚指针的初始化，该虚指针被初始化为本类的虚表。
  所以在程序中，不管你的对象类型如何转换，但该对象内部的虚表指针是固定的，所以呢，才能实现动态的对象函数调用，这就是C++多态性实现的原理。

10.虚函数原理
  1）编译器在发现父类中有虚函数时，会自动为每个含有虚函数的类生成一份虚函数表，也叫做虚表，该表是一个一维数组，虚表里保存了虚函数的入口地址。
  2）编译器会在每个对象的前四个字节中保存一个虚表指针，即（vptr),指向对象所属类的虚表。
    在程序运行时的合适时机，根据对象的类型去初始化vptr，从而让vptr指向正确的虚表，从而在调用虚函数时，能找到正确的函数。
  3）在派生类定义对象时，程序运行会自动调用构造函数，在构造函数中创建虚表并对虚表初始化。
    在构造子类对象时，会先调用父类的构造函数，此时，编译器只“看到了”父类，并为父类对象初始化虚表指针，令它指向父类的虚表；
    当调用子类的构造函数时，为子类对象初始化虚表指针，令它指向子类的虚表
    
11.const
  1)#define与const的区别
    a)宏定义的常量没有类型，只是简单的字符串替换，const定义的常量有类型，存放在静态存储区
    b)宏定义的变量在预处理时进行替换，可能有多个拷贝，const定义的变量在编译时确定其值，只有一个拷贝
    c)宏定义的常量不可以用指针区指向，const可以
    d)宏定义可以定义简单的函数，const不行    
  2）const修饰类的成员变量，常量不能被修改；修饰类的成员函数，函数不会修改类中的数据成员，不会调用非const成员函数；而非const函数可以调用const函数
  3）const char *p指向字符常量的指针，即常量指针，指向可以改变，指向的值不能改变
     char const *p等同于const char *p
     char* const p指向字符的指针常量，即指针常量，指向不能改变，指向的值可以改变

12.C++的内存管理
  1）静态存储区：内存在编译时已经分配好，存放全局变量、静态变量及常量；
  2）栈区：执行函数时，函数内局部变量内存在栈上创建，执行结束后编译器自动释放；
  3）堆区：动态内存分配，用new/malloc申请内存，程序员负责创建和释放。
  
13.内存泄漏
  动态分配的堆内存未释放或无法释放，造成系统内存浪费
  1）类的构造和析构函数中的new和delete没有配套；
  2）释放数组delete[]；
  3）没有将基类的析构函数定义为虚函数：当基类指针指向子类对象时，若析构函数不是virtual，子类的析构函数不会被调用，子类的资源没有释放
  4）没有清除嵌套的对象指针
  
14.栈溢出
  函数中的局部变量造成的溢出，栈大小1-2M
  1）函数调用层次过深，调用一次，局部变量、参数压栈一次；
  2）局部变量内存过大；
  解决方法：
  1）增大分配内存大小
  2)使用堆内存：定义指针，动态申请/static

15.野指针
  未初始化或未清零的指针，指向的内存不确定
  1）指针未初始化；
  2）指针指向的内存被释放，但指针没有被置空；
  3）指针超过变量的作用范围，即指针越界。
  
16.函数调用过程
  1）栈内存分配存储空间；
  2）实参的存储空间复制值到形参栈空间
  3）运算
  形参在函数调用前没有内存空间，调用结束后，形参弹出栈空间，清除内存；
  数组作为参数的函数调用是地址传递，形参和实参指向相同空间，调用结束后，形参指针被销毁，但指向的空间依然存在；
  多个返回值，返回地址/指针。
  
17.堆栈区别
  1）栈存放函数参数，局部变量，编译器自动释放；
  2）堆由new/malloc开辟，程序员delete/free手动释放，若未释放，操作系统自动回收；
  3）堆的内存空间不连续，有大量碎片；
  4）堆的生长空间自下而上，地址越大；栈生长空间自上而下，地址越小。

18.struct/class/union
  struct和class权限：struct默认公有，class默认私有
  struct和union：
  1）struct时不同类型数据组合成一个整体，是自定义类型，union不同类型变量共同占有一段内存；
  2）struct各成员有独立地址，同时存在；union同一时刻只有一个成员有内存；
  3）sizeof(struct)是内存对齐后所有成员长度的和，sizeof(union)是最长数据成员的长度。

19.struct为什么要内存对齐
  1）平台移植：硬件平台不能访问任意地址上的任意数据；
  2）硬件原因：内存对齐后，CPU访问速度大大提升。

20.深拷贝和浅拷贝
  深拷贝：在堆区重新申请空间，进行拷贝；浅拷贝：简单的复制拷贝
  类的对象发生复制过程时，资源重新分配了就是深拷贝，没有重新分配就是浅拷贝；
  浅拷贝会导致重复释放堆区内存。
  
21.拷贝构造函数的调用时机
  1）使用一个一创建的对象初始化新对象；
  2）值传递的方式给函数参数传值；
  3）以值方式返回局部对象
  
